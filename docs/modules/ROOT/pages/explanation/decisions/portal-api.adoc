= {product} Portal API

== Problem

For the xref:explanation/system/details-ui.adoc[{product} Portal] an API endpoint is needed which implements and exposes the backend functionality.
This API endpoint is described in xref:explanation/system/details-external-services.adoc[External Services] in more detail.
As documented there, this API endpoint connects various third-party backend systems together and presents them in a well-defined uniform way for the Portal UI or other API clients to be consumed.

It must be possible to connect to various different backend systems which implement the same functionality so that it is a pluggable system and can be re-used by other parties, which might have different backends for the same task.

{product} API only specifies the interface, the implementation is then specific to the provider of the API.

== Relevant requirements

* xref:references/quality-requirements/maintainability/portal-api-modularity.adoc[Portal API Modularity]
* xref:references/quality-requirements/reliability/portal-api-data-recoverability.adoc[Portal API Data Recoverability]
* xref:references/quality-requirements/performance/portal-api-data-freshness.adoc[Portal API Data Freshness]

== Proposals

[qanda]
Custom API implementation::
Implementation of a custom (REST or GraphQL) API which connects to all the backend system and provides the abstraction to them.
This can be a synchronous or asynchronous connection, depending on the implementation.
Authentication, authorization and other core API features will have to be implemented specific to this API.

Kubernetes API::
Use the Kubernetes API server to leverage all the core-plumbing which already exists there: Authentication, RBAC, scalability, well-defined resource-model, extensibility with `CRDs`, aggregated API server and much more.
This seems to be a common topic in the Cloud Native world, see for example the experiment called https://github.com/kcp-dev/kcp[kcp - a minimal Kubernetes API server].
+
A CLI client could be there "for free" if wanted. The Kubernetes CLI client `kubectl` can display and work with the custom API endpoints of the Portal API out-of-the-box.
+
Implementation-wise the core https://kubernetes.io/docs/concepts/extend-kubernetes/[extensibility features] of the Kubernetes API server are leveraged.
This could mean that the API specification is written as CRDs and the backend functionality implemented as a https://kubernetes.io/docs/concepts/architecture/controller/[Kubernetes controller].
Even the https://github.com/crossplane/crossplane-runtime[crossplane-runtime] could be used to write the backend functionality, which is an SDK designed to especially work with external third-party APIs.

== Decision

Kubernetes API

== Rationale

The Kubernetes API approach has been chosen because the engineers at VSHN have a lot of know-how working with it.
It allows to start fast as the important API plumbing is provided right from the beginning from the Kubernetes API server.

== Additional information

There are a lot of other topics provided by the Kubernetes API server:

Authentication::
The same authentication processes can be leveraged which is already in use for authenticating against {zone}s.
Authentication is built-in to the Kubernetes API server and it's even pluggable.

Authorization::
The standard Kubernetes RBAC access control can be used and could even be enhanced with a policy engine like Kyverno.

Asynchronous::
It allows to build upon an asynchronous and eventual-consistenct architecture which VSHN has a lot of experience with due to VSHNs day-to-day business with Kubernetes.

Persistent Storage::
Storing ephemeral data is built-in directly in the core, if there should be a need for it.
Temporary data can be stored without having to implement a storage backend.

API Extensibility and Versioning::
The API can easily be extended by leveraging `CustomResourceDefinition` (CRDs).
By leveraging the built-in https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning[API versioning] it makes it easier to progress the API into future iterations.

API definition vs. Implementation::
By using `CustomResourceDefinition` (CRDs) to define the API structure, we can easily decouple the interface and the implementation.

Scalability and Availability::
It's a core feature of the Kubernetes API server to be highly scalable.

Implementation boilerplate with kubebuilder::
For the implementation of the CRD-defined interface, there already exists a good ecosystem, like kubebuilder, Operator SDK or crossplane-runtime.
VSHN already has a lot of experience writing Kubernetes-based controllers (like K8up) and knows how to work with the Kubernetes API.

Frontend Development and Testing::
For the implementation and testing of the Portal API frontend, the backend implementation doesn't actually need to exist.
Data can be faked by just creating test-objects, defined by the custom CRDs, until the actual implementation of the controller is done ("Fake it 'till you make it").
It also allows for having a simple test environment.
This would also hold true for the custom API implementation, but would be much more engineering effort.

Experience from Project Syn::
Project Syn features a similar architecture which serves as inspiration.
